<<<<<<< HEAD
﻿using ITI2016.Dev;
using System;

namespace ITI2016.Dev
{
    class Dictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        List<KeyValuePair<TKey, TValue>> _list;

        public Dictionary()
        {
            _list = new List<KeyValuePair<TKey, TValue>>();
=======
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ITI2016.Dev
{
    public class Dictionary<TKey, TValue> : IDictionary<TKey, TValue>
    {
        class Node
        {
            public readonly TKey Key;
            public TValue Value;
            public Node Next;
            public Node( TKey k )
            {
                Key = k;
            }
        }
        Node[] _buckets;
        int _count;
        IEqualityComparer<TKey> _comparer;

        int FindBucketIndex( TKey k ) =>  Math.Abs( _comparer.GetHashCode( k ) ) % _buckets.Length;

        Node FindNodeInBucket( int idxBucket, TKey k )
        {
            Node candidate = _buckets[idxBucket];
            while( candidate != null )
            {
                if( _comparer.Equals( candidate.Key, k ) ) break;
                candidate = candidate.Next;
            }
            return candidate;
        }

        public Dictionary( IEqualityComparer<TKey> comparer = null )
        {
            if( comparer == null ) comparer = EqualityComparer<TKey>.Default;
            _comparer = comparer;
            _buckets = new Node[7];
>>>>>>> c0906eec09fcc8e591403f147625ef711a73fb23
        }

        public TValue this[TKey k]
        {
            get
            {
<<<<<<< HEAD
                foreach (KeyValuePair<TKey, TValue> keyValuePair in _list)
                {
                    if (keyValuePair.Key.Equals(k))
                    {
                        return keyValuePair.Value;
                    }
                }
                
                throw new ArgumentException();
=======
                // 1 - Finds the bucket index.
                int idxBucket = FindBucketIndex( k );
                // 2 - Finds the Node in the linked list where node.Key equals k.
                Node n = FindNodeInBucket( idxBucket, k );
                // 3 - if node is found returns node.Value otherwise throws a KeyNotFoundException.
                if( n != null ) return n.Value;
                throw new KeyNotFoundException();
>>>>>>> c0906eec09fcc8e591403f147625ef711a73fb23
            }

            set
            {
<<<<<<< HEAD
                bool setted = false;
                IEnumerator<KeyValuePair<TKey, TValue>> enumerator = GetEnumerator();
                int index = -1;
                while (enumerator.MoveNext())
                {
                    index++;
                    if (enumerator.Current.Key.Equals(k))
                    {
                        _list[index] = new KeyValuePair<TKey, TValue>(k, value);
                        setted = true;
                        break;
                    }
                }

                if (!setted)
                {
                    performAdd(k, value);
=======
                // 1 - Finds the bucket index.
                int idxBucket = FindBucketIndex( k );
                // 2 - Finds the Node in the linked list where node.Key equals k.
                Node n = FindNodeInBucket( idxBucket, k );
                // 3 - if node found, updates node.Value to value.
                //     Otherwise inserts a new Node in the linked list with k and v.
                if( n != null ) n.Value = value;
                else
                {
                    _buckets[idxBucket] = new Node( k )
                    {
                        Value = value,
                        Next = _buckets[idxBucket]
                    };
                    ++_count;
>>>>>>> c0906eec09fcc8e591403f147625ef711a73fb23
                }
            }
        }

<<<<<<< HEAD
        private void performAdd(TKey k, TValue v)
        {
            _list.Add(new KeyValuePair<TKey, TValue>(k, v));
        }

        public int Count
        {
            get
            {
                return _list.Count;
            }
        }

        public IEnumerable<TKey> Keys
        {
            get
            {
                List<TKey> enumerable = new List<TKey>();
                foreach (KeyValuePair<TKey, TValue> keyValuePair in _list)
                {
                    enumerable.Add(keyValuePair.Key);
                }

                return enumerable;
            }
        }

        public IEnumerable<TValue> Values
        {
            get
            {
                List<TValue> enumerable = new List<TValue>();
                foreach (KeyValuePair<TKey, TValue> keyValuePair in _list)
                {
                    enumerable.Add(keyValuePair.Value);
                }

                return enumerable;
            }
        }

        public void Add(TKey k, TValue v)
        {
            if (ContainsKey(k))
            {
                throw new InvalidOperationException();
            }

            performAdd(k, v);
        }

        public bool ContainsKey(TKey k)
        {
            foreach (KeyValuePair<TKey, TValue> keyValuePair in _list)
            {
                if (keyValuePair.Key.Equals(k))
                {
                    return true;
                }
            }

            return false;
        }

        public bool ContainsValue(TValue v)
        {
            foreach (KeyValuePair<TKey, TValue> keyValuePair in _list)
            {
                if (keyValuePair.Value.Equals(v))
                {
                    return true;
                }
            }

            return false;
=======
        public int Count => _count;

        public IEnumerable<TKey> Keys
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        public IEnumerable<TValue> Values
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        public void Add( TKey k, TValue v )
        {
            // 1 - Finds the bucket index.
            int idxBucket = FindBucketIndex( k );
            // 2 - Finds the Node in the linked list where node.Key equals k.
            Node n = FindNodeInBucket( idxBucket, k );
            // 3 - if node found, throws an ArgumentException.
            //     Otherwise inserts a new Node in the linked list with k and v.
            if( n != null ) throw new ArgumentException();
            else
            {
                _buckets[idxBucket] = new Node( k )
                {
                    Value = v,
                    Next = _buckets[idxBucket]
                };
                ++_count;
            }
        }

        public bool ContainsKey( TKey k ) => FindNodeInBucket( FindBucketIndex( k ), k ) != null;

        public bool ContainsValue( TValue v )
        {
            for( int i = 0; i < _buckets.Length; i++ )
            {
                Node n = _buckets[i];
                while( n != null )
                {
                    if( 
                        (n.Value != null && n.Value.Equals( v ))
                        ||
                        (n.Value == null && v == null)
                        ) return true;
                    n = n.Next;
                }
            }
            return false;
        }

        public class E : IEnumerator<KeyValuePair<TKey, TValue>>
        {
            readonly Dictionary<TKey, TValue> _owner;
            int _idxBuket;
            Node _node;

            public E( Dictionary<TKey,TValue> d )
            {
                _owner = d;
                _idxBuket = -1;
            }

            public KeyValuePair<TKey, TValue> Current
            {
                get
                {
                    if( _node == null ) throw new InvalidOperationException();
                    return new KeyValuePair<TKey, TValue>( _node.Key, _node.Value );
                }
            }

            public bool MoveNext()
            {
                if( _node == null )
                {
                    if( _idxBuket != -1 ) return false;
                }
                else _node = _node.Next;
                while( _node == null && ++_idxBuket < _owner._buckets.Length )
                {
                    _node = _owner._buckets[_idxBuket];
                }
                return _node != null;
            }

            public void Dispose()
            {
            }
>>>>>>> c0906eec09fcc8e591403f147625ef711a73fb23
        }

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
<<<<<<< HEAD
            return _list.GetEnumerator();
        }

        public bool Remove(TKey key)
        {
            IEnumerator<KeyValuePair<TKey, TValue>> enumerator = GetEnumerator();
            int index = -1;
            while (enumerator.MoveNext())
            {
                index++;
                if (enumerator.Current.Key.Equals(key))
                {
                    _list.RemoveAt(index);
                    return true;
                }
            }

=======
            return new E( this );
        }

        public bool Remove( TKey key )
        {
            // 1 - Finds the bucket index.
            int idxBucket = FindBucketIndex( key );
            // 2 - Finds the Node in the linked list where node.Key equals k.
            Node prevNode = null;
            Node n = _buckets[idxBucket];
            while( n != null )
            {
                if( _comparer.Equals( n.Key, key ) ) break;
                prevNode = n;
                n = n.Next;
            }
            // 3 - If node found, removes it and returns true.
            //     Otherwise returns false.
            if( n != null )
            {
                if( prevNode == null )
                {
                    _buckets[idxBucket] = n.Next;
                }
                else
                {
                    prevNode.Next = n.Next;
                }
                --_count;
                return true;
            }
            return false;
        }

        public bool TryGetValue( TKey k, out TValue v )
        {
            // 1 - Finds the bucket index.
            int idxBucket = FindBucketIndex( k );
            // 2 - Finds the Node in the linked list where node.Key equals k.
            Node n = FindNodeInBucket( idxBucket, k );
            // 3 - if node is found sets value to node.Value and returns true.
            //     Otherwise sets value to default(TValue) and returns false.
            if( n != null )
            {
                v = n.Value;
                return true;
            }
            v = default( TValue );
>>>>>>> c0906eec09fcc8e591403f147625ef711a73fb23
            return false;
        }
    }
}
